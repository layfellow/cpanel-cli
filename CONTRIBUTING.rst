=================
How to contribute
=================

`LÉAME en español <#como-contribuir>`_

To contribute, just fork this repository, make a new branch and open a `pull request`_.

.. _`pull request`: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request

**cpanel-cli** is written in Python (version 3.11 or later required). I organized the code into a standard tree::

    cpanel-cli
    ├── API.md
    ├── CONTRIBUTING.rst
    ├── cpanel
    │   ├── cli.py
    │   ├── core.py
    │   ├── __init__.py
    │   ├── __main__.py
    │   ├── REFERENCE
    │   └── USAGE
    ├── doc
    │   ├── conf.py
    │   ├── contributing.rst
    │   ├── index.rst
    │   ├── locale
    │   │   └── es
    │   │       └── LC_MESSAGES
    │   │           ├── contributing.po
    │   │           ├── index.po
    │   │           ├── installation.po
    │   │           ├── reference.po
    │   │           └── reference
    │   │               └─── *.po
    │   ├── reference.sh
    │   ├── requirements.txt
    │   └── _static
    │       ├─── *.svg
    │       └─── *.png
    ├── hatch.py
    ├── LICENSE
    ├── Makefile
    ├── pyproject.toml
    ├── pyrightconfig.json
    ├── README.rst
    ├── .readthedocs.yaml
    ├── test
    │   ├── cpanelrc.test.example
    │   └── test_core.py
    └── tox.ini

``cpanel`` contains the main source code. Files ``REFERENCE`` and ``USAGE`` contain the actual
text for the ``--help`` and ``--version`` flags and the ``help`` command. (I keep them in
external files to make them easier to change. Also, I can automatically parse ``REFERENCE`` to
generate ``*.rst`` files for the Sphinx documentation builder.
See the ``reference.sh`` script below.)

Standard ``pyproject.toml`` contains the project metadata, development and release dependencies,
and build backend definitions. (See `Writing your pyproject.toml`_ for further info.)

.. _`Writing your pyproject.toml`: https://packaging.python.org/en/latest/guides/writing-pyproject-toml/

I’m using the `Hatchling`_ build backend, with a small custom ``hatch.py`` script to get the
``dynamic`` metadata properties in ``pyproject.toml``. The custom ``hatch.py`` script works by parsing the
``cpanel/__init__.py`` source file.

.. _`Hatchling`: https://pypi.org/project/hatchling/

``pyrightconfig.json`` is the configuration file for the `Pyright`_ static type checker.

``test`` contains a set of unit API tests. They’re written using the `tox automation framework`_.
The code driving the tests is in ``test/test_core.py``; the main tox configuration file is ``tox.ini``.
These are *not* simple standalone unit tests, but API tests running against
a *live* cPanel instance. See `Running tests`_ below for further details.

.. _`tox automation framework`: https://tox.wiki/en/latest/index.html

``doc`` contains the documentation sources, written in `reStructuredText`_ and processed using `Sphinx`_.
The main configuration file for Sphinx is ``doc/conf.py``. The Sphinx version and theme used
to build the documentation are in ``doc/requirements.txt``.

.. _`reStructuredText`: https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html
.. _Sphinx: https://www.sphinx-doc.org/

The source files for the documentation are in ``doc/*.rst``. The ``index.rst`` file is the main
page. You will notice a ``doc/reference`` folder and a series of ``*.rst`` files on it.
These are programmatically generated by the ``reference.sh`` script and need *not* be edited manually.
(I’m committing them to the source tree because they serve as the actual source files for Sphinx.)

The ``reference.sh`` script generates ``doc/reference.rst`` and the files inside ``doc/reference/``
by parsing the ``REFERENCE`` text file, splitting it into sections and converting them to restructuredText.
This allows me to keep ``REFERENCE`` as a single source of truth for the documentation
and keep the Sphinx documents up to date.

``_static`` contains the images and SVG files used in the documentation.

``.readthedocs.yaml`` is a `configuration file for Read the Docs`_. The remote Sphinx build system
uses this file.

.. _`configuration file for Read the Docs`: https://docs.readthedocs.io/en/stable/config-file/index.html

I maintain a Spanish translation of the documentation, generated using strings from a series of
catalog files (``*.po``) inside ``locale/es/LC_MESSAGES/``. See `Translations`_ for further information.

Finally, I’m using a ``Makefile`` to automate all phases of the development life cycle.
(`Make and Makefiles are awesome`_.)

.. _`Make and Makefiles are awesome`: https://mplanchard.com/posts/make-and-makefiles-are-awesome.html


Development environment
=======================

I developed **cpanel-cli** on Ubuntu Linux 23.10 “Mantic” with Python 3.11.
**cpanel-cli**, however, has no special requirements, so any Linux distro
supporting at least Python 3.11 should work. You can also use macOS “Ventura”
or a later macOS release.

*To create a development environment on macOS*:

Install Python 3.11:

.. code:: sh

    $ brew install python@3.11

Add the following to your ``PATH``:

.. code:: sh

    PATH="$PATH:/usr/local/opt/python@3.11/Frameworks/Python.framework/Versions/3.11/bin"
    export $PATH

(You can replace ``3.11`` with a higher version.)

Install GNU Make:

.. code:: sh

    $ brew install make

*To create a development environment on Linux:*

On a Debian-based distro (Ubuntu, Mint), install Python 3.11 using:

.. code:: sh

    $ sudo apt install python3.11 python3-pip python3.11-venv

On a RPM-based distro (RHEL, Fedora), install Python 3.11 using:

.. code:: sh

    $ sudo dnf install python3.11 python3-pip

(You can replace ``3.11`` with a higher version.)

GNU Make is installed by default on most Linux distros. Check its availability using:

.. code:: sh

    $ make --version

Building a local ``cpanel-cli`` package from source
===================================================

Build and install a local ``cpanel-cli`` package:

.. code:: sh

    $ make install

This will:

1. Create a new virtual Python 3 environment in a ``venv`` directory

2. Locally install in ``venv`` the development packages listed on the ``[project.optional-dependencies]`` section of ``pyproject.toml``

3. Build a local Python package ``cpanel-cli``

Running the local executable
============================

To run the executable, first activate the virtual environment
(you need to run this only once per session):

.. code:: sh

    $ source venv/bin/activate

Then run the ``cpanel`` utility:

.. code:: sh

    $ cpanel --help

If you edit the sources, just re-run ``make install`` to build and reinstall
the local package.

Running the (optional) type checker
===================================

*Running the type checker is optional — you can ignore this step if you want.*

The Python source code is annotated using type hints. I use them
to add clarity and robustness to Python code. Read the `Python Type Checking Guide`_ for an
excelente introduction.

.. _`Python Type Checking Guide`: https://realpython.com/python-type-checking/

Type hints are not actually checked by the Python runtime — you need a
third party *type checker* utility.
For this project I use Pyright_, which is my Python type checker of choice.

.. _Pyright: https://github.com/Microsoft/pyright

To install Pyright:

.. code:: sh

    $ pip3 install --user pyright

Run it using:

.. code:: sh

    $ make typecheck

The type checker configuration is in the ``pyrightconfig.json`` file.

Note that Pyright is based on Node.js, so that pip will indirectly install it and pull a
lot of JavaScript dependencies.

Running tests
=============

I’m using the `tox automation framework`_ for a series of unit API tests.
The main code driving the tests is in ``test/test_core.py``; the main tox configuration file is
``tox.ini``.

These are *not* simple unit tests, but unit API tests running against a *live* cPanel instance.
To run the tests, you need access to a cPanel instance running on another host reachable from
the host you’re running the tests on.

To set the remote hosts credentials, make a copy of the provided ``cpanelrc.test.example`` file
and name it ``cpanelrc.test`` (keep in the ``test`` directory):

.. code:: sh

    $ cp test/cpanelrc.test.example test/cpanelrc.test

Then edit ``cpanelrc.test`` and set:

- The hostname of your cPanel instance
- The username of your cPanel account
- An `API token`_ associated to that username

**Token-based authentication is the only supported authentication method.**

.. _`API token`: https://docs.cpanel.net/knowledge-base/security/how-to-use-cpanel-api-tokens/

To run the tests, use:

.. code:: sh

    $ make test

The above command will hit the `cPanel UAPI REST interface`_ with most of the functions
implemented in **cpanel-cli**.

**The remote state of cPanel is left unchanged, i.e., the tests are strictly non-destructive.**

.. _`cPanel UAPI REST interface`: https://api.docs.cpanel.net/cpanel/introduction/

Packaging
=========

Packaging is done via the `Hatchling`_ build backend, as specified on the ``[build-system]``
section of ``pyproject.toml``.

To run the packager, use:

.. code:: sh

    $ make package

The above command should generate the following two distribution files in the
temporary ``dist`` directory:

.. code:: sh

    cpanel_cli-<version>-py3-none-any.whl
    cpanel-cli-<version>.tar.gz

where ``<version>`` is the release number set in ``cpanel/__init__.py``.

The tarball is the source archive; the wheel file is the built distribution archive. The
included files for these distribution packages are listed on the ``[tool.hatch.build.targets.sdist]`` and
``[tool.hatch.build.targets.wheel]`` sections of ``pyproject.toml`` respectively.

These packages are ready to be uploaded to the `Python Package Index`_.

.. _`Python Package Index`: https://pypi.org/

Building the documentation
==========================

The API documentation source files are in the ``doc`` directory. These comprise `reStructuredText`_
(``.rst``) files which are processed using `Sphinx`_ into groups of static HTML trees.

To build the documentation, use:

.. code:: sh

    $ make doc

The above command will generate several static HTML trees in ``doc/build/html``.
For example, it generates the default English documentation in ``doc/build/html/en`` —
the start page is a conventional ``index.html`` file.

This GitHub repository is currently connected to my `Read the Docs`_ account, so that
any committed (or merged) change that updates the documentation sources will automatically
trigger a remote Sphinx rebuild. The resulting updated HTML documentation will always be
available at https://cpanel-cli.readthedocs.io/en/stable/

.. _`Read the Docs`: https://readthedocs.org/

The main configuration file for Sphinx is ``doc/conf.py``. The Sphinx version and theme used
to build the documentation are in ``doc/requirements.txt``.

Translations
============

The English language ``*.rst`` files in ``doc`` are the source documentation files. Any
translation is based on these documents. Translation is done on a string-by-string basis,
using the original English string as a key (``msgid``), and the corresponding translated
string as a value (``msgstr``). For example, for Spanish:

.. code::

    msgid "To be, or not to be, that is the question"
    msgstr "Ser o no ser, he ahí el dilema"

These ``msgid`` and ``msgstr`` pairs are kept in a *catalog* file (``*.po``), which is a
simple text file. These catalog files are stored in the ``doc/locale`` subdirectory.

I personally maintain a Spanish translation of the documentation in catalog files
``doc/locale/es/LC_MESSAGES/*.po``.

Catalog ``.po`` files are compiled into ``.mo`` files using the Sphinx internationalization
utility. These compiled ``.mo`` files are later used to compose translated versions when
`Building the documentation`_.

Adding a translation
--------------------

To add a new translation:

1. Create a new catalog using:

   .. code:: sh

       $ make locale iso=<language code>

   where ``<language code>`` is the `ISO 639-1 code`_ corresponding to the new language. For
   example, to add a French translation you would use:

   .. code:: sh

       $ make locale iso=fr

   This would add a new ``locale/fr/LC_MESSAGES/index.po`` directory with several ``.po``
   files in it.

2. Edit the ``.po`` files created in step 1 and insert the translated strings as
   ``msgstr`` fields. For example:

   .. code:: sh

       msgid "Indices and tables"
       msgstr "Indices et tableaux"

3. Rebuild the documentation:

   .. code:: sh

       $ make doc

   The above command will create a new static HTML tree in ``doc/build/html/<language code>``.
   For example, for French, it will create a new tree in ``doc/build/html/fr``.

Correcting and expanding an existing translation
------------------------------------------------

if you edit the original ``doc/*.rst`` source documentation files, you need to update the
translations as well:

1. Run the following to update the catalog files:

   .. code:: sh

       $ make locale iso=<language code>

   where ``<language code>`` is the `ISO 639-1 code`_. You need to run it for every
   translated language.

2. The previous step will emit a report telling you which ``.po`` files need to be updated,
   for example:

   .. code::

       Update: doc/locale/es/LC_MESSAGES/reference.po +5, -2
       Update: doc/locale/es/LC_MESSAGES/contributing.po +9, -0

   Open the mentioned ``.po`` files and edit or add new ``msgstr`` strings. Be advised that some
   entries might get annotated as ``#, fuzzy``, which means the internationalization
   engine is not sure if there already exists a translation for the entry because of similarities
   with another entry. Just edit the ``msgstr`` text and delete the ``fuzzy`` line.

For further information, see the `Internationalization Guide`_

.. _`ISO 639-1 code`: https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
.. _`Internationalization Guide`: https://www.sphinx-doc.org/en/master/usage/advanced/intl.html


----


===============
Cómo contribuir
===============

`README in English <#how-to-contribute>`_

Para contribuir, haga un fork de este repositorio, cree una nueva rama y abra un `pull request`_.

**cpanel-cli** está escrito en Python (versión 3.11 o posterior). El código está organizado en este árbol::

    cpanel-cli
    ├── API.md
    ├── CONTRIBUTING.rst
    ├── cpanel
    │   ├── cli.py
    │   ├── core.py
    │   ├── __init__.py
    │   ├── __main__.py
    │   ├── REFERENCE
    │   └── USAGE
    ├── doc
    │   ├── conf.py
    │   ├── contributing.rst
    │   ├── index.rst
    │   ├── locale
    │   │   └── es
    │   │       └── LC_MESSAGES
    │   │           ├── contributing.po
    │   │           ├── index.po
    │   │           ├── installation.po
    │   │           ├── reference.po
    │   │           └── reference
    │   │               └─── *.po
    │   ├── reference.sh
    │   ├── requirements.txt
    │   └── _static
    │       ├─── *.svg
    │       └─── *.png
    ├── hatch.py
    ├── LICENSE
    ├── Makefile
    ├── pyproject.toml
    ├── pyrightconfig.json
    ├── README.rst
    ├── .readthedocs.yaml
    ├── test
    │   ├── cpanelrc.test.example
    │   └── test_core.py
    └── tox.ini

``cpanel`` contiene el código fuente principal. Los archivos ``REFERENCE`` y ``USAGE`` contienen
el texto para las opciones ``--help`` y ``--version`` y el comando ``help``. (Los mantengo en
archivos externos para que sea más fácil editarlos. Además, puedo analizar programáticamente
``REFERENCE`` para generar los archivos ``*.rst`` para el constructor de documentación Sphinx.
Vea el script ``reference.sh`` más abajo).

El archivo ``pyproject.toml`` estándar contiene los metadatos del proyecto, las dependencias de
desarrollo y publicación, y las definiciones del backend de compilación.
(Vea `Writing your pyproject.toml`_ para más información.)

Uso el backend de construcción `Hatchling`_, con un pequeño script personalizado ``hatch.py`` para
obtener las propiedades de metadatos ``dynamic`` en ``pyproject.toml``. El script ``hatch.py`` funciona
analizando el archivo fuente ``cpanel/__init__.py``.

``pyrightconfig.json`` es el archivo de configuración para el verificador de tipos
estáticos `Pyright`_.

``test`` contiene un conjunto de pruebas unitarias de la API. Están escritas usando el
`framework de automatización tox`_. El código que controla las pruebas está en
``test/test_core.py``; el archivo de configuración principal de tox es ``tox.ini``.
Nótese que *no* son simples pruebas unitarias independientes, sino pruebas de API que se ejecutan
en una instancia de cPanel *activa*. Vea `Ejecución de pruebas`_ más abajo para más detalles.

.. _`framework de automatización tox`: https://tox.wiki/en/latest/index.html

``doc`` contiene las fuentes de la documentación, escritas en `reStructuredText`_ y procesadas
usando `Sphinx`_. El archivo de configuración principal de Sphinx es ``doc/conf.py``. La versión
de Sphinx y el tema para construir la documentación están en ``doc/requirements.txt``.

Las fuentes de la documentación están en ``doc/*.rst``. El archivo ``index.rst`` es la página
principal. Nótese una carpeta ``doc/reference`` y una serie de archivos ``*.rst`` en ésta.
Éstos son generados programáticamente por el script ``reference.sh`` y *no* necesitan ser editados
manualmente. (Los subo al repositorio porque Sphinx los usa como sus archivos fuentes).

El script ``reference.sh`` genera ``doc/reference.rst`` y los archivos dentro de ``doc/reference/``
analizando el archivo de texto ``REFERENCE``, dividiéndolo en secciones y convirtiéndolas a
restructuredText. Esto me permite mantener ``REFERENCE`` como una única fuente de verdad para
la documentación y mantener los archivos de Sphinx actualizados.

``_static`` contiene las imágenes y archivos SVG utilizados en la documentación.

``.readthedocs.yaml`` es un `archivo de configuración para Read the Docs`_. El sistema remoto de Sphinx
utiliza este archivo.

.. _`archivo de configuración para Read the Docs`: https://docs.readthedocs.io/en/stable/config-file/index.html

También mantengo una traducción al español de la documentación, generada usando cadenas de una serie
de archivos de catálogo (``*.po``) dentro de ``locale/es/LC_MESSAGES/``.
Vea `Traducciones`_ para más información.

Finalmente, uso un ``Makefile`` para automatizar todas las fases del ciclo de vida del desarrollo.
(`Make y los Makefiles son increíbles`_.)

.. _`Make y los Makefiles son increíbles`: https://mplanchard.com/posts/make-and-makefiles-are-awesome.html


Entorno de desarrollo
=====================

**cpanel-cli** fue desarrollado en Ubuntu Linux 23.10 “Mantic” con Python 3.11.
Sin embargo **cpanel-cli** no tiene ningún requerimiento especial, por lo que
cualquier distribución de Linux que soporte al menos Python 3.11 debería funcionar.
También puede utilizar macOS “Ventura” o posterior.

*Para crear un entorno de desarrollo en macOS*:

Instale Python 3.11:

.. code:: sh

    $ brew install python@3.11

Agregue lo siguiente al ``PATH``:

.. code:: sh

    PATH="PATH:/usr/local/opt/python@3.11/Frameworks/Python.framework/Versions/3.11/bin"
    export PATH

(Puede reemplazar ``3.11`` con una versión superior.)

Instale GNU Make:

.. code:: sh

    $ brew install make

*Para crear un entorno de desarrollo en Linux:*

Para distros basadas en Debian (Ubuntu, Mint), instale Python 3.11 con:

.. code:: sh

    $ sudo apt install python3.11 python3-pip python3.11-venv

Para distros basadas en RPM (RHEL, Fedora), instale Python 3.11 con:

.. code:: sh

    $ sudo dnf install python3.11 python3-pip

(Puede reemplazar ``3.11`` con una versión superior.)

GNU Make está instalado por defecto en la mayoría de las distros de Linux.
Verifique su disponibilidad usando:

.. code:: sh

    $ make --version

Construcción del paquete ``cpanel-cli`` a partir del código fuente
==================================================================

Para construir e instalar un paquete local ``cpanel-cli`` use:

.. code:: sh

    $ make install

Lo anterior ejecuta lo siguiente:

1. Crea un nuevo entorno virtual de Python 3 en un directorio ``venv``

2. Instala en ``venv`` los paquetes de desarrollo listados en la sección ``[project.optional-dependencies]`` de ``pyproject.toml``

3. Construye un paquete local de Python ``cpanel-cli``


Ejecución local
===============

Para ejecutar el paquete instalado localmente, primero active el entorno virtual
(necesita ejecutar esto sólo una vez por sesión):

.. code:: sh

    $ source venv/bin/activate

Luego ejecute el utilitario ``cpanel``:

.. code:: sh

    $ cpanel --help

Si edita las fuentes, simplemente ejecute de nuevo ``make install`` para construir y
reinstalar el paquete local.


Ejecución (opcional) del verificador de tipos
=============================================

*El verificador de tipos es opcional; puede ignorar este paso si lo desea.*

El código fuente de Python está anotado usando sugerencias de tipos (*type hints*).
Las uso para añadir claridad y robustez al código. Lea la `Guía de verificación de tipos en Python`_
para una excelente introducción.

.. _`Guía de verificación de tipos en Python`: https://realpython.com/python-type-checking/

Las sugerencias de tipos no son realmente verificadas por el runtime de Python;
necesita un utilitario de un tercero.
Para este proyecto uso Pyright_, que es mi verificador de tipos preferido para Python.

Para instalar Pyright:

.. code:: sh

    $ pip3 install --user pyright

Ejecútelo con:

.. code:: sh

    $ make typecheck

La configuración del verificador de tipos están en el archivo `pyrightconfig.json``.

Tenga en cuenta que Pyright está basado en Node.js, por lo que pip instalará indirectamente
este y un montón de dependencias de JavaScript.

Ejecución de pruebas
====================

Para las pruebas unitarias del API uso el `framework de automatización tox`_. El código que
controla las pruebas está en ``test/test_core.py``; el archivo de configuración principal de
tox es ``tox.ini``.

Éstas *no* son pruebas unitarias simples, sino pruebas unitarias de API que se ejecutan contra
una instancia `en vivo` de cPanel. Por esto, tox necesita acceso a una instancia de cPanel
activa en algún host remoto accesible desde el host local.

Para establecer las credenciales del host remoto, haga una copia del archivo proporcionado
``cpanelrc.test.example`` y cámbiele el nombre a ``cpanelrc.test`` (manténgalo en el directorio
``test``):

.. code:: sh

    $ cp test/cpanelrc.test.example test/cpanelrc.test


Luego edite ``cpanelrc.test`` y proporcione los siguientes datos:

- ``hostname``: El nombre del host remoto de la instancia de cPanel
- ``username``: El nombre de usuario de su cuenta de cPanel
- ``utoken``: Un `token de API`_ asociado a ese nombre de usuario

**La autenticación basada en tokens es el único método de autenticación soportado.**

.. _`token de API`: https://docs.cpanel.net/knowledge-base/security/how-to-use-cpanel-api-tokens/

Para ejecutar las pruebas, use:

.. code:: sh

    $ make test

El comando anterior accede a un subconjunto de la `interfaz REST de cPanel UAPI`_ con las funciones
implementadas en **cpanel-cli**.

**El estado remoto de cPanel se deja sin cambios, es decir, las pruebas son estrictamente no
destructivas.**

.. _`interfaz REST de cPanel UAPI`: https://api.docs.cpanel.net/cpanel/introduction/

Empaquetado
===========

El empaquetado se realiza a través del backend de construcción `Hatchling`_, como se
especifica en la sección ``[build-system]`` de ``pyproject.toml``.

Para ejecutar el empaquetador, use:

.. code:: sh

    $ make package

El comando anterior debería generar los siguientes dos archivos de distribución
en el directorio temporal ``dist``:

.. code:: sh

    cpanel_cli-<version>-py3-none-any.whl
    cpanel-cli-<version>.tar.gz

donde ``<version>`` es el número de versión establecido en ``cpanel/__init__.py``.

El archivo tar contiene el código fuente; el archivo wheel es el archivo de distribución
binaria para instalación. Los archivos incluidos para estos paquetes de distribución
están listados en las secciones ``[tool.hatch.build.targets.sdist]`` y
``[tool.hatch.build.targets.wheel]`` de ``pyproject.toml`` respectivamente.

Estos paquetes están listos para ser subidos al `Python Package Index`_.

Construcción de la documentación
================================

Los archivos fuente de la documentación de la API están en el directorio ``doc``. Estos comprenden
archivos `reStructuredText`_ (``.rst``) que se procesan con `Sphinx`_ para generar árboles HTML estáticos.

Para construir la documentación utilice:

.. code:: sh

    $ make doc

El comando anterior genera varios árboles HTML estáticos en ``doc/build/html``.
Por ejemplo, la documentación por defecto en inglés se genera en ``doc/build/html/en``;
la página de inicio es un archivo convencional ``index.html``.

Este repositorio de GitHub está actualmente conectado a mi cuenta de `Read the Docs`_, de modo que
cualquier cambio en un ``commit`` (o ``merge``) que actualice las fuentes de documentación
dispara automáticamente una reconstrucción remota de Sphinx. La documentación HTML resultante está siempre disponible en
https://cpanel-cli.readthedocs.io/es/stable/

El archivo de configuración principal para Sphinx es ``doc/conf.py``. La versión de Sphinx y el tema
usado para construir la documentación están en ``doc/requirements.txt``.

Traducciones
============

Los archivos ``.*rst`` en ``doc`` son las fuentes de los archivos de documentación. Todas las
traducciones se basan en estos documentos. La traducción se realiza cadena por cadena, utilizando
la cadena original en inglés como clave (``.msgid``), y la correspondiente cadena traducida como
valor (``msgstr``). Por ejemplo, para español:

.. code::

    msgid "To be, or not to be, that is the question"
    msgstr "Ser o no ser, he ahí el dilema"

Estos pares ``msgid`` y ``msgstr`` se guardan en un archivo de catálogo (``.*po``), que es un
archivo de texto simple. Estos archivos de catálogo se almacenan en el subdirectorio ``doc/locale``.

La traducción al español de la documentación la mantengo personalmente en los archivos de
catálogo ``.doc/locale/es/LC_MESSAGES/*.po``.

Los archivos ``.po`` de catálogo se compilan en archivos ``.mo`` con el utilitario de
internacionalización de Sphinx. Estos archivos ``.mo`` compilados se utilizan luego para componer
las versiones traducidas durante la `Construcción de la documentación`_.

Cómo añadir una traducción
--------------------------

Para añadir una nueva traducción:

1. Cree un nuevo catálogo:

   .. code:: sh

       $ make locale iso=<código de idioma>

   donde ``<código de idioma>`` es el `código ISO 639-1`_ correspondiente al nuevo idioma. Por
   ejemplo, para añadir una traducción al francés se utilizaría:

   .. code:: sh

       $ make locale iso=fr

   Esto añadiría un nuevo directorio ``locale/fr/LC_MESSAGES`` con varios archivos ``.po``.

2. Edite los archivo ``.po`` creados en el paso 1 e inserte las cadenas traducidas
   como campos ``msgstr``. Por ejemplo:

   .. code:: sh

       msgid "Indices and tables"
       msgstr "Indices et tableaux"

3. Reconstruya la documentación:

   .. code:: sh

       $ make doc

   El comando anterior crea un nuevo árbol HTML estático en ``doc/build/html/<código de idioma>``.
   Por ejemplo, para el francés, crearía un nuevo árbol en ``doc/build/html/fr``.

Cómo corregir y ampliar una traducción existente
------------------------------------------------

Si se edita el texto de los archivos de documentación originales ``doc/*.rst``, también hay
que actualizar las traducciones:

1. Ejecute lo siguiente para actualizar los catálogos:

   .. code:: sh

       $ make locale iso=<language code>

   donde ``<language code>`` es el `código ISO 639-1`_. Tiene que ejecutarlo para cada lenguaje
   traducido.

2. El paso anterior emite un informe con los archivos ``.po`` que necesitan ser actualizados,
   por ejemplo:

   .. code::

       Update: doc/locale/es/LC_MESSAGES/reference.po +5, -2
       Update: doc/locale/es/LC_MESSAGES/contributing.po +9, -0

   Abra los archivos ``.po`` mencionados y edite o agregue nuevas cadenas ``msgstr``.
   Tenga en cuenta que algunas entradas pueden ser anotadas como ``#, fuzzy``, lo que significa
   que el motor de internacionalización no está seguro si ya existe una traducción
   para esa entrada debido a similitudes con otra entrada. Sólo se necesita editar el texto de
   ``msgstr`` y eliminar la línea ``fuzzy``.

Para más información consulte la `Guía de internacionalización`_.

.. _`código ISO 639-1`: https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
.. _`Guía de internacionalización`: https://www.sphinx-doc.org/en/master/usage/advanced/intl.html
